/**
 * Pre-commit hook generator
 *
 * Generates sophisticated pre-commit hooks based on configuration
 */

import type { PreCommitConfig, PreCommitCustomCommand } from '../../types/config.js';

/**
 * Generate the complete pre-commit hook script
 */
export function generatePreCommitScript(config: PreCommitConfig): string {
  if (!config.enabled) {
    return generateDisabledScript();
  }

  const sections: string[] = [];

  // Header with husky setup
  sections.push(generateHeader());

  // Timing setup
  if (config.showTiming) {
    sections.push(generateTimingSetup());
  }

  // Error handling setup
  sections.push(generateErrorHandling(config.continueOnFailure));

  // Lint check
  if (config.lint.enabled) {
    sections.push(generateLintSection(config));
  }

  // Type check
  if (config.typecheck.enabled) {
    sections.push(generateTypecheckSection(config));
  }

  // Format check
  if (config.formatCheck.enabled) {
    sections.push(generateFormatCheckSection(config));
  }

  // Tests
  if (config.tests.enabled && config.tests.mode !== 'none') {
    sections.push(generateTestSection(config));
  }

  // Custom commands (sorted by order)
  const sortedCustom = [...config.customCommands].sort(
    (a, b) => (a.order ?? 100) - (b.order ?? 100)
  );
  for (const cmd of sortedCustom) {
    sections.push(generateCustomCommandSection(cmd, config));
  }

  // Footer with final status
  sections.push(generateFooter(config));

  return sections.join('\n\n');
}

/**
 * Generate script for disabled pre-commit
 */
function generateDisabledScript(): string {
  return `#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

# Pre-commit hook disabled
exit 0`;
}

/**
 * Generate header section
 */
function generateHeader(): string {
  return `#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

# Pre-commit hook - Generated by @qazuor/claude-code-config
# Bypass with: git commit --no-verify -m "message"

echo "üîç Running pre-commit checks..."`;
}

/**
 * Generate timing setup
 */
function generateTimingSetup(): string {
  return `# Timing setup
START_TIME=$(date +%s)
step_start() { STEP_START=$(date +%s); }
step_end() {
  STEP_END=$(date +%s)
  ELAPSED_TIME=$((STEP_END - STEP_START))
  echo "  ‚è±Ô∏è  Completed in \${ELAPSED_TIME}s"
}`;
}

/**
 * Generate error handling
 */
function generateErrorHandling(continueOnFailure: boolean): string {
  if (continueOnFailure) {
    return `# Error tracking (continue on failure mode)
ERRORS=0
track_error() {
  ERRORS=$((ERRORS + 1))
}`;
  }
  return `# Fail fast mode - exit on first error
set -e`;
}

/**
 * Generate lint section
 */
function generateLintSection(config: PreCommitConfig): string {
  const lint = config.lint;
  let command: string;

  if (lint.command) {
    command = lint.command;
  } else if (lint.stagedOnly) {
    command = getLintStagedCommand(lint.tool);
  } else {
    command = getLintCommand(lint.tool);
  }

  const lines: string[] = [];
  lines.push('# Linting');
  lines.push('echo ""');
  lines.push('echo "üìù Linting..."');

  if (config.showTiming) {
    lines.push('step_start');
  }

  if (lint.allowFailure) {
    lines.push(`if ${command}; then`);
    lines.push('  echo "  ‚úÖ Lint passed"');
    lines.push('else');
    lines.push('  echo "  ‚ö†Ô∏è  Lint warnings (non-blocking)"');
    lines.push('fi');
  } else if (config.continueOnFailure) {
    lines.push(`if ${command}; then`);
    lines.push('  echo "  ‚úÖ Lint passed"');
    lines.push('else');
    lines.push('  echo "  ‚ùå Lint failed"');
    lines.push('  track_error');
    lines.push('fi');
  } else {
    lines.push(`${command} || { echo "  ‚ùå Lint failed"; exit 1; }`);
    lines.push('echo "  ‚úÖ Lint passed"');
  }

  if (config.showTiming) {
    lines.push('step_end');
  }

  return lines.join('\n');
}

/**
 * Get lint staged command for tool
 */
function getLintStagedCommand(tool?: string): string {
  switch (tool) {
    case 'biome':
      return 'pnpm biome check --staged --no-errors-on-unmatched';
    case 'eslint':
      return 'pnpm lint-staged';
    default:
      return 'pnpm lint-staged';
  }
}

/**
 * Get full lint command for tool
 */
function getLintCommand(tool?: string): string {
  switch (tool) {
    case 'biome':
      return 'pnpm biome check .';
    case 'eslint':
      return 'pnpm eslint .';
    default:
      return 'pnpm lint';
  }
}

/**
 * Generate typecheck section
 */
function generateTypecheckSection(config: PreCommitConfig): string {
  const typecheck = config.typecheck;
  const command = typecheck.command ?? 'pnpm typecheck';

  const lines: string[] = [];
  lines.push('# Type checking');
  lines.push('echo ""');
  lines.push('echo "üî∑ Type checking..."');

  if (config.showTiming) {
    lines.push('step_start');
  }

  if (typecheck.allowFailure) {
    lines.push(`if ${command}; then`);
    lines.push('  echo "  ‚úÖ Types OK"');
    lines.push('else');
    lines.push('  echo "  ‚ö†Ô∏è  Type warnings (non-blocking)"');
    lines.push('fi');
  } else if (config.continueOnFailure) {
    lines.push(`if ${command}; then`);
    lines.push('  echo "  ‚úÖ Types OK"');
    lines.push('else');
    lines.push('  echo "  ‚ùå Type check failed"');
    lines.push('  track_error');
    lines.push('fi');
  } else {
    lines.push(`${command} || { echo "  ‚ùå Type check failed"; exit 1; }`);
    lines.push('echo "  ‚úÖ Types OK"');
  }

  if (config.showTiming) {
    lines.push('step_end');
  }

  return lines.join('\n');
}

/**
 * Generate format check section
 */
function generateFormatCheckSection(config: PreCommitConfig): string {
  const format = config.formatCheck;
  let command: string;

  if (format.command) {
    command = format.command;
  } else {
    command = getFormatCheckCommand(format.tool);
  }

  const lines: string[] = [];
  lines.push('# Format check');
  lines.push('echo ""');
  lines.push('echo "‚ú® Format check..."');

  if (config.showTiming) {
    lines.push('step_start');
  }

  if (format.allowFailure) {
    lines.push(`if ${command}; then`);
    lines.push('  echo "  ‚úÖ Format OK"');
    lines.push('else');
    lines.push('  echo "  ‚ö†Ô∏è  Format warnings (non-blocking)"');
    lines.push('fi');
  } else if (config.continueOnFailure) {
    lines.push(`if ${command}; then`);
    lines.push('  echo "  ‚úÖ Format OK"');
    lines.push('else');
    lines.push('  echo "  ‚ùå Format check failed"');
    lines.push('  track_error');
    lines.push('fi');
  } else {
    lines.push(`${command} || { echo "  ‚ùå Format check failed"; exit 1; }`);
    lines.push('echo "  ‚úÖ Format OK"');
  }

  if (config.showTiming) {
    lines.push('step_end');
  }

  return lines.join('\n');
}

/**
 * Get format check command for tool
 */
function getFormatCheckCommand(tool?: string): string {
  switch (tool) {
    case 'biome':
      return 'pnpm biome format --check .';
    case 'prettier':
      return 'pnpm prettier --check .';
    default:
      return 'pnpm format:check';
  }
}

/**
 * Generate test section
 */
function generateTestSection(config: PreCommitConfig): string {
  const tests = config.tests;
  let command: string;

  if (tests.command) {
    command = tests.command;
  } else if (tests.mode === 'affected') {
    command = 'pnpm vitest related --run';
  } else {
    command = 'pnpm test';
  }

  // Add coverage threshold if specified
  if (tests.coverageThreshold > 0) {
    command = `${command} --coverage --coverage.thresholds.lines=${tests.coverageThreshold}`;
  }

  const lines: string[] = [];
  lines.push('# Tests');
  lines.push('echo ""');
  lines.push(`echo "üß™ Running ${tests.mode === 'affected' ? 'affected' : 'all'} tests..."`);

  if (config.showTiming) {
    lines.push('step_start');
  }

  if (tests.allowFailure) {
    lines.push(`if ${command}; then`);
    lines.push('  echo "  ‚úÖ Tests passed"');
    lines.push('else');
    lines.push('  echo "  ‚ö†Ô∏è  Test warnings (non-blocking)"');
    lines.push('fi');
  } else if (config.continueOnFailure) {
    lines.push(`if ${command}; then`);
    lines.push('  echo "  ‚úÖ Tests passed"');
    lines.push('else');
    lines.push('  echo "  ‚ùå Tests failed"');
    lines.push('  track_error');
    lines.push('fi');
  } else {
    lines.push(`${command} || { echo "  ‚ùå Tests failed"; exit 1; }`);
    lines.push('echo "  ‚úÖ Tests passed"');
  }

  if (config.showTiming) {
    lines.push('step_end');
  }

  return lines.join('\n');
}

/**
 * Generate custom command section
 */
function generateCustomCommandSection(
  cmd: PreCommitCustomCommand,
  config: PreCommitConfig
): string {
  const lines: string[] = [];
  lines.push(`# Custom: ${cmd.name}`);
  lines.push('echo ""');
  lines.push(`echo "üîß ${cmd.name}..."`);

  if (config.showTiming) {
    lines.push('step_start');
  }

  if (cmd.allowFailure) {
    lines.push(`if ${cmd.command}; then`);
    lines.push(`  echo "  ‚úÖ ${cmd.name} passed"`);
    lines.push('else');
    lines.push(`  echo "  ‚ö†Ô∏è  ${cmd.name} warnings (non-blocking)"`);
    lines.push('fi');
  } else if (config.continueOnFailure) {
    lines.push(`if ${cmd.command}; then`);
    lines.push(`  echo "  ‚úÖ ${cmd.name} passed"`);
    lines.push('else');
    lines.push(`  echo "  ‚ùå ${cmd.name} failed"`);
    lines.push('  track_error');
    lines.push('fi');
  } else {
    lines.push(`${cmd.command} || { echo "  ‚ùå ${cmd.name} failed"; exit 1; }`);
    lines.push(`echo "  ‚úÖ ${cmd.name} passed"`);
  }

  if (config.showTiming) {
    lines.push('step_end');
  }

  return lines.join('\n');
}

/**
 * Generate footer section
 */
function generateFooter(config: PreCommitConfig): string {
  const lines: string[] = [];
  lines.push('# Final status');
  lines.push('echo ""');

  if (config.showTiming) {
    lines.push('END_TIME=$(date +%s)');
    lines.push('TOTAL_TIME=$((END_TIME - START_TIME))');
  }

  if (config.continueOnFailure) {
    lines.push('if [ $ERRORS -gt 0 ]; then');
    lines.push('  echo "‚ùå Pre-commit failed with $ERRORS error(s)"');
    if (config.showTiming) {
      lines.push('  echo "‚è±Ô∏è  Total time: ${TOTAL_TIME}s"');
    }
    lines.push('  exit 1');
    lines.push('fi');
  }

  if (config.showTiming) {
    lines.push('echo "‚ú® All checks passed! (${TOTAL_TIME}s)"');
  } else {
    lines.push('echo "‚ú® All checks passed!"');
  }

  return lines.join('\n');
}

/**
 * Generate a simple pre-commit hook (legacy compatibility)
 */
export function generateSimplePreCommitHook(command: string): string {
  return `#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

${command}`;
}
