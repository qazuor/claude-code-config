/**
 * Hook configurator - generates and installs hook scripts
 */

import type { HookConfig } from '../../types/config.js';
import { ensureDir, joinPath, makeExecutable, pathExists, writeFile } from '../utils/fs.js';

const HOOKS_DIR = '.claude/hooks';

/**
 * Generate hook scripts based on configuration
 */
export async function installHooks(
  projectPath: string,
  config: HookConfig
): Promise<{ installed: string[]; errors: string[] }> {
  const installed: string[] = [];
  const errors: string[] = [];

  if (!config.enabled) {
    return { installed, errors };
  }

  const hooksDir = joinPath(projectPath, HOOKS_DIR);
  await ensureDir(hooksDir);

  // Install notification hook
  if (config.notification) {
    try {
      const script = generateNotificationHook(config.notification);
      const scriptPath = joinPath(hooksDir, 'notification.sh');
      await writeFile(scriptPath, script);
      await makeExecutable(scriptPath);
      installed.push('notification.sh');
    } catch (error) {
      errors.push(`notification hook: ${error}`);
    }
  }

  // Install stop hook
  if (config.stop) {
    try {
      const script = generateStopHook(config.stop);
      const scriptPath = joinPath(hooksDir, 'stop.sh');
      await writeFile(scriptPath, script);
      await makeExecutable(scriptPath);
      installed.push('stop.sh');
    } catch (error) {
      errors.push(`stop hook: ${error}`);
    }
  }

  // Install subagent stop hook
  if (config.subagentStop) {
    try {
      const script = generateSubagentStopHook(config.subagentStop);
      const scriptPath = joinPath(hooksDir, 'subagent-stop.sh');
      await writeFile(scriptPath, script);
      await makeExecutable(scriptPath);
      installed.push('subagent-stop.sh');
    } catch (error) {
      errors.push(`subagent-stop hook: ${error}`);
    }
  }

  return { installed, errors };
}

/**
 * Generate notification hook script
 */
function generateNotificationHook(config: HookConfig['notification']): string {
  if (!config) return '';

  const lines: string[] = [
    '#!/bin/bash',
    '# Claude Code notification hook',
    '# Generated by @qazuor/claude-code-config',
    '',
    'MESSAGE="${1:-Claude needs your attention}"',
    '',
  ];

  // Desktop notification
  if (config.desktop) {
    lines.push(
      '# Desktop notification',
      'if command -v notify-send &> /dev/null; then',
      '  notify-send "Claude Code" "$MESSAGE" --icon=dialog-information',
      'elif command -v terminal-notifier &> /dev/null; then',
      '  terminal-notifier -title "Claude Code" -message "$MESSAGE"',
      'elif command -v osascript &> /dev/null; then',
      '  osascript -e "display notification \\"$MESSAGE\\" with title \\"Claude Code\\""',
      'fi',
      ''
    );
  }

  // Audio notification
  if (config.audio) {
    lines.push(
      '# Audio notification (text-to-speech)',
      'if command -v piper &> /dev/null; then',
      '  echo "$MESSAGE" | piper --model ~/.local/share/piper/voices/en_US-hfc_male-medium.onnx --output-raw | aplay -r 22050 -f S16_LE -t raw - 2>/dev/null',
      'elif command -v say &> /dev/null; then',
      '  say "$MESSAGE"',
      'elif command -v espeak &> /dev/null; then',
      '  espeak "$MESSAGE"',
      'fi',
      ''
    );
  }

  // Custom command
  if (config.customCommand) {
    lines.push('# Custom notification command', `${config.customCommand} "$MESSAGE"`, '');
  }

  return lines.join('\n');
}

/**
 * Generate stop hook script
 */
function generateStopHook(config: HookConfig['stop']): string {
  if (!config) return '';

  const lines: string[] = [
    '#!/bin/bash',
    '# Claude Code stop hook',
    '# Generated by @qazuor/claude-code-config',
    '',
  ];

  if (config.beep) {
    lines.push(
      '# Play beep sound',
      'if command -v aplay &> /dev/null; then',
      '  # Generate a beep using speaker-test or beep command',
      '  ( speaker-test -t sine -f 1000 -l 1 ) &>/dev/null & pid=$!; sleep 0.2; kill -9 $pid &>/dev/null',
      'elif command -v afplay &> /dev/null; then',
      '  afplay /System/Library/Sounds/Glass.aiff',
      'elif command -v powershell.exe &> /dev/null; then',
      '  powershell.exe -c "[console]::beep(1000,200)"',
      'else',
      '  printf "\\a"',
      'fi',
      ''
    );
  } else if (config.customSound) {
    lines.push(
      '# Play custom sound',
      `SOUND_FILE="${config.customSound}"`,
      'if command -v aplay &> /dev/null; then',
      '  aplay "$SOUND_FILE" 2>/dev/null',
      'elif command -v afplay &> /dev/null; then',
      '  afplay "$SOUND_FILE"',
      'elif command -v paplay &> /dev/null; then',
      '  paplay "$SOUND_FILE"',
      'fi',
      ''
    );
  } else if (config.customCommand) {
    lines.push('# Custom stop command', config.customCommand, '');
  }

  return lines.join('\n');
}

/**
 * Generate subagent stop hook script
 */
function generateSubagentStopHook(config: HookConfig['subagentStop']): string {
  if (!config) return '';

  const lines: string[] = [
    '#!/bin/bash',
    '# Claude Code subagent stop hook',
    '# Generated by @qazuor/claude-code-config',
    '',
  ];

  if (config.beep) {
    lines.push(
      '# Play short beep',
      'if command -v aplay &> /dev/null; then',
      '  ( speaker-test -t sine -f 800 -l 1 ) &>/dev/null & pid=$!; sleep 0.1; kill -9 $pid &>/dev/null',
      'elif command -v afplay &> /dev/null; then',
      '  afplay /System/Library/Sounds/Pop.aiff',
      'else',
      '  printf "\\a"',
      'fi',
      ''
    );
  } else if (config.customSound) {
    lines.push(
      '# Play custom sound',
      `SOUND_FILE="${config.customSound}"`,
      'if command -v aplay &> /dev/null; then',
      '  aplay "$SOUND_FILE" 2>/dev/null',
      'elif command -v afplay &> /dev/null; then',
      '  afplay "$SOUND_FILE"',
      'fi',
      ''
    );
  } else if (config.customCommand) {
    lines.push('# Custom subagent stop command', config.customCommand, '');
  }

  return lines.join('\n');
}

/**
 * Get hooks status
 */
export async function getHooksStatus(projectPath: string): Promise<{
  enabled: boolean;
  hooks: Array<{ name: string; exists: boolean; executable: boolean }>;
}> {
  const hooksDir = joinPath(projectPath, HOOKS_DIR);
  const hookFiles = ['notification.sh', 'stop.sh', 'subagent-stop.sh'];
  const hooks: Array<{ name: string; exists: boolean; executable: boolean }> = [];

  for (const file of hookFiles) {
    const filePath = joinPath(hooksDir, file);
    const exists = await pathExists(filePath);

    let executable = false;
    if (exists) {
      try {
        const fs = await import('node:fs/promises');
        const stats = await fs.stat(filePath);
        executable = (stats.mode & 0o111) !== 0;
      } catch {
        // Ignore
      }
    }

    hooks.push({ name: file, exists, executable });
  }

  return {
    enabled: hooks.some((h) => h.exists),
    hooks,
  };
}
